/* NOTES
?--Strings are finite sequences of symbols from the alphabet (Σ)
    - w = abaaa
        - to "concatenate" 2 strings w and v::
            w = a1a2...an
                or... w = abaaa
            v = b1b2...b3
                or... v = abcde
            wv = a1a2...anb1b2...bm
                or... wv = abaaaabcde
        - the "reverse" of a string is obtained by writing symbols in reverse order::
            w_reversed = aaaba
        - the "length" of a string, |w|::
            |\\\lambda| = 0 // λ will be used to denote the empty string frequently in this course
        - a "substring" of w is any string of consecutive symbols in some w
            w = vu // w is composed of 2 substrings, v and u
        !- if w is a string, then w^n stands for the string obtained by repeating w n times
            w^2 = abaaaabaaa
            as a special case:: w^0 = λ
        !- if E is an alphabet, ten we use E` to denote the set f strings obtained by concatenating zero or more symbols from E.  The set E` always contains λ.  To exclude \lamda::
            E+ = E` - {λ}
        ! - a string in a language L will be called a sentence of L
            EX:: Let E = {a, b}, then E* = {λ + every combination of a, b}
                the set [a, aa, aab] is a language on E because it has a finite number of sentences, we call it a finite language.
                the set L = {a^nb^n:n>=0} is also a language on E.  The strings aabb and aaaabbbb are in the language L, but the string abb is not in L.
                Despite this, L is an infinite language.
            - since languages are sets, the union, intersection, and difference of two languages are known::
                complement of L: L = E* - L
                reverse of L: L^R = {w^R: w in L}
    ?- the concatenation of two languages L1 and L2 is the set of all strings obtained by concatenating any element of L1 with any element of L2::
        L1L2 = {xy: x in L1, y in L2}
    - L^0 = {\lambda}
    - L^1 = L
    - the !star closure of a language is::
        l* = L^0 union L^1 union L^2 ...
    - the ?positive closure of a language is::
        L* = L1 union L2 ... // So just no empty string
    
? GRAMMAR!
    - A grammar for the English language tells us whether a particular sentance is well formed or not...
    !- For this class' sake, a grammar G is defined as a quadruple::
        G = ( V, T, S, P ),
        !Where V isa finite set of objects called variales,
        ?T is a finite set of objects called terminal suymbols,
        ^S in V is a special symbol called the start variable,
        &P is a finite set of productions
        It is assumed that the sets V and T arre nonempty and disjoint // disjoint means their elements are unique
    ^- Production rules:
        the heart of a grammar - specify how the grammar transforms one string into another
        we will assume that all production rules are of the form::
            x -> y
            where x is an element of (V union T)+ and y is in (V union T)*
        !so... given a string W of the form::
            W = uxv
            we say the production x -> y is applicable ot htis string, and we may use it to replace x with y such that::
            Z = uyv
            this transformation is written asL W => Z
        - since this transformation happened, we say that W derives Z or that Z is derived from ws
        - How does this apply to grammars?
            Let G = ( V, T, S, P )
            Then the set: L(G) = { W ∈ T* : S => w } is the language generated by G
    !- two grammars are equivalent if they generate the same language::
        if L(G_1) = L(G_2)

? AUTOMATA!!
    - an automaton is an abstract model of a digital computer
    - each automaton has essential features::
        mechanism for reading input
            - it is assumed that the input is a string over a given alphabet, written on an input file which the bot can read but not change
            - the input file is divided into cells, each of which can hold one symbol
        a mechanism for producing output
        temporary storage
        control unit || can be in any one of a finite number of internal states
        &SEE /CTRL_Unit.png for a diagram
    - they are assumed to operate in a discrete time frame
    - at any given time, the CU is in some internal state
    - this internal state at the next time step is determined by the next-state, the current input symbol, and the information currently in the temp. storage
        - these states together will be called a configuration, and changing states will be called a move
    !- A deterministic automata is one in which each move is uniquely determined by the current configuration
        !This means they are predictable!
    !- A nondeterministic automata has multiple possible moves, so we can only predict possible actions, not definite ones
    - An automaton whose output response is limited to just yes or no is called an accepter, when presented with a string, the accepter accepts or rejects the string
    - A more general automaton, capable of producing strings of symbols is called a transducer!
    ? FOR VIDEO NOTES, SEE NOTEBOOK
*/

//!SET THEORY REFRESHER!
/* Quick Refresher on set theory symbols::
^ Membership
∈   ||  element of
∉   ||  not element of

^ Subsets // Supersets
A ⊆ B   ||  A is a subset of B, they can be equal
A ⊂ B   ||  A is a subset of B, they cannot be equal
A ⊇ B   ||  B is a subset of A, they can be equal (A is a superset of B)
A ⊃ B   ||  B is a subset of A, they cannot be equal (A is a superset of B)

^ Set Operations
A ∪ B    ||  All elements of A or B or both
A ∩ B    ||  Elements in BOTH A and B
A ∖ (or -) B   ||  Elements in A that are NOT in B

^ OTHER
∅       ||  Empty set
A × B    ||  Cartesian product (all ordered pairs where a ∈ A and b ∈ B)
≈       ||  Loose equivalence
~       ||  Relation
P(A)    ||  Powerset of A (a set of ALL subsets of A)
*/


#include <stdio.h>
int main(void) {
    printf("Notes for section 1.2");
    return 0;
}